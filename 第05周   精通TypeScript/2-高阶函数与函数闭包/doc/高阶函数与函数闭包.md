## 1、一等公民与高阶函数

### 基本用法

```typescript
let a = [5,1,2,3,11,14,22,35]
a.sort()

console.log(a)  //输出非大小值排序的数组 [1, 11, 14, 2, 22, 3, 35, 5] 
```

为了解决上面问题，于是需要我们自定义排序函数

```typescript
// a<b ==> 返回负数
// a=b ==> 返回0
// a>b ==> 返回正数
function compareNum(a:number,b:number):number{
  console.log('comparing',a, b)
	return a-b
}

let a = [5,1,2,3,11,14,22,35]
a.sort(compareNum)
```

与函数指针的区别

函数指针就是单纯的指针，js中的函数变量比指针要复杂的多，具有很多特性，比如高阶函数、闭包、部分应用函数等等。



**上面的案例比较像函数指针的用法，接下来案例 绝大部分都是函数指针不具备的能力**



### 函数作为一等公民

#### 概念

- 变量类型可以是函数
- 值（literal）可以是函数
- 对象的字段可以是函数
- 函数的参数可以是函数
- 函数的返回值可以是函数



#### 变量类型可以是函数

#### 值可以是函数

```typescript
let a = [5,1,2,3,11,14,22,35]

//推断出类型 (a:number,b:number) => number,再次赋值的时候不能赋值其他类型的函数
const compareNum = function(a:number,b:number):number{
  console.log('comparing',a, b)
	return a-b
}

//推荐这种写法，和上面的等效。lambda 表达式，在js中又叫箭头函数
let compareNum = (a:number,b:number) => a-b
//函数不一定有名字
a.sort((a:number,b:number) => a-b)

//如果使用大括号，就必须有return，像正常的函数体语句一样
a.sort((a:number,b:number) => {
  console.log('comparing',a, b)
  return a-b
})

//a,b不写也能知道是number类型，因为数组是number类型，如果编译器能推断出，倾向于不写类型
a.sort((a,b) => {
  console.log('comparing',a, b)
  return a-b
})
```

#### 对象的字段可以是函数

```typescript
const emp1 = {
  name:'jone',
  gender:'male',
  salary:8000,
  //increaseSalary 就是对象的字段，也可以这样写 increaseSalary: function (p:number){ }
  //也可以写成箭头函数，这里 因为 this 冲突，不能改写成箭头函数。
  increaseSalary(p:number){ 
     this.salary *= p
  },
}

emp1.increaseSalary(1.1)
console.log(emp1)
```

#### 函数的返回值可以是函数

```typescript
function createComparer(){
  return (a:number,b:number) => a-b
}

let a = [5,1,2,3,11,14,22,35]
console.log(a.sort(createComparer()))
```

通过参数控制返回函数的功能

```typescript
function createComparer(smallerFirst:boolean){
  if(smallerFirst){
    return (a:number,b:number) => a-b
  }else{
    return (a:number,b:number) => b-a
  }
}

let a = [5,1,2,3,11,14,22,35]
console.log(a.sort(createComparer(false)))
```

对象类型参数能解决 布尔参数 不能清晰看到参数含义的问题

```typescript
function createComparer(p:{smallerFirst:boolean}){
  if(p.smallerFirst){
    return (a:number,b:number) => a-b
  }else{
    return (a:number,b:number) => b-a
  }
}

let a = [5,1,2,3,11,14,22,35]
console.log(a.sort(createComparer({smallerFirst:false})))
```



### 高阶函数

createComparer() 就是一个高阶函数，高阶函数就是不断重复，比如说 函数的返回值函数的返回值也是函数

下面案例，参数是函数，返回值也是函数

```typescript
function loggingCompare(comp:(a:number,b:number)=>number){
  return (a:number,b:number)=>{
    console.log('comparing',a, b)
    return comp(a,b)
  }
}

function createComparer(p:{smallerFirst:boolean}){
  if(p.smallerFirst){
    return (a:number,b:number) => a-b
  }else{
    return (a:number,b:number) => b-a
  }
}

let a = [5,1,2,3,11,14,22,35]
const comp = createComparer({smallerFirst:false})
console.log(a.sort(loggingCompare(comp)))
```

