## 1.数组

### 定义数组的几种方法

```go
var arr1 [5]int
arr2 := [3]int{3, 4, 5}   //自动推算类型
arr3 := [...]int{3, 4, 5} //让编译器计算数组长度

var grid [4][5]int
fmt.Println(arr1, arr2, arr3)
fmt.Println(grid)

输出：
[0 0 0 0 0] [3 4 5] [3 4 5]
[[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]]
```

### range关键字 进行数组遍历

```go
for i, v := range arr3 {
    fmt.Println(i, v)   //i:数组下标，  v:数组元素
}

//如果只要i,就写成
for i= range arr3 {
    fmt.Println(arr3[i])  
}
```

### 为什么要用range?

1.意义明确，美观

2.C++ 没有类似的能力

3.Java/Python 只能foreach value,不能同时获取 i,v



### 数组是值类型

```go
// []int 代表切片，[5]int 才是数组
func printArray(arr [5]int) {
	for i, v := range arr {
		fmt.Println(i, v)
	}
	arr[0] = 100  //数组是值类型，函数内部改变数组的值，不会影响外部的数组
}
两次执行 printArray(arr3)，输出结果不变
```

- [10]int 和 [20]int 是不同的类型
- 调用func f ( arr [10]int ) 会**拷贝数组**

### 改用指针简化操作

```go
//改用指针，简化操作
func printArray2(arr *[5]int) {
	for i, v := range arr {
		fmt.Println(i, v)
	}
	arr[0] = 100
}

printArray2(&arr3)		//使用指针改变外部数组的值
fmt.Println("指针赋值后")
fmt.Println(arr3)

输出：
指针赋值后
[100 4 5 7 8]
```

由于传参数需要指定数组的长度，特别不方便，Go语言一般不使用数组传参，而是使用 **切片** 代替。

## 2.切片 Slice

### 切片定义

```go
arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
s := arr[2:6]  //s就是一个切片 s的值是 [2,3,4,5]  半开半闭区间，不包含6

fmt.Println("arr[2:6] =", arr[2:6])
fmt.Println("arr[:6] =", arr[:6])
fmt.Println("arr[2:] =", arr[2:])
fmt.Println("arr[:] =", arr[:])

输出：
arr[2:6] = [2 3 4 5]
arr[:6] = [0 1 2 3 4 5]
arr[2:] = [2 3 4 5 6 7]
arr[:] = [0 1 2 3 4 5 6 7]
```

### 切片更新

slice是数组的视图，slice内部有一个数据结构

```go
func updateSlice(s []int) {
	s[0] = 100
}


func main() {
	arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
	
	s1 := arr[2:]
	fmt.Println("arr[2:] =", s1)
	s2 := arr[:]
	fmt.Println("arr[:] =", s2)

	fmt.Println("after updateSlice s1")
	updateSlice(s1)
	fmt.Println(s1)
	fmt.Println(arr)
}
输出：
after updateSlice s1
[100 3 4 5 6 7]
[0 1 100 3 4 5 6 7]
```

Slice本身没有数据，是对底层array的一个view。

### Reslice

所有的切片都是对应的同一个数组。

```go
fmt.Println(arr)
fmt.Println("Reslice s2")
s2 = s2[:5]
fmt.Println(s2)
s2 = s2[2:]
fmt.Println(s2)
输出：
[0 1 100 3 4 5 6 7]
Reslice s2
[0 1 100 3 4]
[100 3 4]		
```

### Slice扩展

```go
arr := [...]int{0, 1, 2, 3, 4, 5, 6, 7}
s1:= arr[2:6]
s2:= s1[3:5]
```

- S1的值为？
- S2的值为？

```go
fmt.Println("Extending slice ")
arr[0], arr[2] = 0, 2
s1 = arr[2:6]
s2 = s1[3:5]
fmt.Println("s1 =", s1)
fmt.Println("s2 =", s2)
输出：
Extending slice 
s1 = [2 3 4 5]
s2 = [5 6]  //6不属于s1也能够被输出。
```

### Slice的实现

![1](img/1.png)

- 使用索引取值的时候，索引不能超过len区域。cap里的值都是可以扩展的值。
- slice可以向后扩展，不可以向前扩展
- s[i] 不可用超越len(s), 向后扩展不可以超越底层数组 cap(s)
- s[i:j]  j的值取决于cap  j<cap    j最大值为 cap-1

```go
s1 = arr[2:6]
s2 = s1[3:5]
fmt.Printf("s1=%v, len(s1)=%d,cap(s1)=%d\n", s1, len(s1), cap(s1))
fmt.Printf("s2=%v, len(s2)=%d,cap(s1)=%d\n", s2, len(s2), cap(s2))
输出：
s1=[2 3 4 5], len(s1)=4,cap(s1)=6
s2=[5 6], len(s2)=2,cap(s1)=3
```



