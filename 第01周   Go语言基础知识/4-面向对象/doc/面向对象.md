

## 1、结构体和方法

### 面向对象

- go语言仅支持封装，不支持继承和多态。
- go 语言没有class，只有struct

### 结构的创建

```go
type treeNode struct {
	value       int
	left, right *treeNode
}

func main() {
	//定义方式一
	var root treeNode //会进行初始化
	//方式二
	root = treeNode{value: 3}
	//方式三
	root.left = &treeNode{}
	//方式四
	root.right = &treeNode{5, nil, nil}
	//方式五  new是内置函数，返回值就是地址
	root.right.left = new(treeNode)

	nodes := []treeNode{
		{value: 2},
		{},
		{6, nil, &root},
	}
}
```

- 不论地址还是结构本身，一律使用 **.** 来访问成员。



```go
func createNode(value int) *treeNode {
	return &treeNode{value: value} //返回局部变量的地址，在c++中是非常典型的错误。go语言可以正常使用。
}
root.left = createNode(4)
```

- 使用自定义工厂函数，自己控制构建
- 注意返回了局部变量的地址！

### 为结构定义方法

```go
func (node treeNode) print() {
	fmt.Println(node.value)
}
```

- 显示定义和命名方法接收者。前面括号里边的变量为接收者。用于代替其他语言的this。

```go
func (node *treeNode) setValue(value int) {
	node.value = value //都是使用 . 访问成员变量
}
```

- 只有使用指针才可以改变结构内容
- nil 指针也可以调用方法！但是不能访问成员变量，否则会报异常。本质上不管nil与否，方法的地址是确定的。

### 值接收者VS指针接收者

- 要改变内容必须使用指针接收者
- 结构数据过大也考虑使用指针接收者，值拷贝性能较差
- 一致性：如有指针接收者，最好都是指针接收者（建议，非必须）
- 值接收者 是go语言特有的，其他语言都是指针接收
- 值/指针接收者均可接收值/指针，调用方式没有不同。非指针类型也可以调用指针类型接收者方法，指针也可以调用值接收者方法



### 结构是创建在堆上还是栈上？

答案是	不需要知道。有可能是栈上，也有可能堆上。当发现有return时，需要将变量返回，会分配到堆上，由垃圾回收器负责管理。



## 2、包和封装

### 封装

- 名字一般使用CamelCase
- 首字母大写：public
- 首字母小写：private     

public、private 针对包而言。

### 包

- 每个目录一个包，包名可以和目录名不一样。每个目录只能有一个包。
- main包包含可执行入口。如果一个包下有main函数，则这个包只能是main包。
- 为结构定义的方法必须放在同一个包内
- 可以是不同文件。



